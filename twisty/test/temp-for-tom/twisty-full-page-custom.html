<!DOCTYPE html>
<html>
<head>
  <title>Full-Page Test | twisty.js</title>
 <style>
 twisty { width: 800px; height: 500px; display:block; }
 </style>
  <script src="../../../build/alg/algorithm.js"></script>
  <script src="../../../build/alg/traversal.js"></script>
  <script src="../../../build/alg/example.js"></script>

  <script src="../../../build/ksolve/puzzle_definitions.js"></script>
  <script src="../../../build/ksolve/ksolve.js"></script>
  <script src="../../../build/ksolve/parser.js"></script>

  <script src="../../../build/twisty/puzzle.js"></script>
  <script src="../../../build/twisty/timeline.js"></script>
  <script src="../../../build/twisty/cursor.js"></script>
  <script src="../../../build/twisty/anim.js"></script>
  <script src="../../../build/twisty/widget.js"></script>
  <script src="../../../build/twisty/twisty.js"></script>
  <script src="PuzzleGeometry.js"></script>
  <link href="../../twisty.css" rel="stylesheet" type="text/css">

  <script>
 function LucasSetup(ksolve, svg, movenames) {
    var p = KSolve.createPuzzle(ksolve, svg) ;
    var elem = document.querySelector("#custom-example");
    elem.textContent = "" ;
    var twisty = new Twisty.Twisty(elem, {
      puzzle: p,
      alg: new Alg.Sequence(
        movenames.map(function(f){return new Alg.BlockMove(f,1)})
      )
    });
  }
  </script>
<script>
var lastval ;
var textinput ;
var distance ;
var pg ;
function checkchange() {
   var s = textinput.value ;
   if (s == lastval)
      return ;
   lastval = s ;
   var p = PuzzleGeometry.prototype.parsedesc(s) ;
   if (p) {
      pg = new PuzzleGeometry(p[0], p[1]) ;
      pg.allstickers() ;
      myfaces = pg.getfaces() ;
      distance = pg.vertexdistance * 3 ;
      var desc =
         "Faces " + pg.baseplanerot.length + "<BR>" +
         "Stickers per face " + pg.stickersperface + "<BR>" +
         "Cubies " + pg.cubies.length + "<BR>" +
         "Short edge " + pg.shortedge + "<BR>" +
         "Edge distance " + pg.edgedistance + "<BR>" +
         "Vertex distance " + pg.vertexdistance + "<BR>" ;
      document.getElementById('data').innerHTML = desc ;
      pg.genperms() ;
      changeddisplay() ;
   }
}
function doselection(el) {
   if (el.target.value != '') {
      textinput.value = el.target.value ;
      checkchange() ;
   }
}
var puz = null ;
// given a single edge describing a regular polygon with polyn sides,
// extend it around.
function extendedges(a, polyn) {
   var dx = a[1][0] - a[0][0] ;
   var dy = a[1][1] - a[0][1] ;
   var ang = 2*Math.PI/polyn ;
   var cosa = Math.cos(ang) ;
   var sina = Math.sin(ang) ;
   for (var i=2; i<polyn; i++) {
      var ndx = dx * cosa + dy * sina ;
      dy = dy * cosa - dx * sina ;
      dx = ndx ;
      a.push([a[i-1][0]+dx, a[i-1][1]+dy]) ;
   }
}
function drawedges(id, pts, color) {
   return "<polygon id=\"" + id + "\" class=\"sticker\" style=\"fill: " + color +
      "\" points=\"" +
      pts.map(function(p){return p[0] + " " + p[1]}).join(" ") +
      "\"/>\n" ;
}
// Find a net from a given face count.  Walk it, assuming we locate
// the first edge from (0,0) to (1,1) and compute the minimum and
// maximum vertex locations from this.  Then do a second walk, and
// assign the actual geometry.
var pos = [] ;
var colormap = [] ;
var facegeo = [] ;
var trim ;
var canwidth ;
var canheight ;
function walknet(pg, fn, w, h) {
   var net = pg.net ;
   if (net == null) {
      alert("No net for " + fn + " faces.") ;
      return ;
   }
   var polyn = net[0].length - 1 ;
   var edges = {} ;
   var minx = 0 ;
   var miny = 0 ;
   var maxx = 1 ;
   var maxy = 0 ;
   edges[net[0][0]] = [[1, 0], [0, 0]] ;
   extendedges(edges[net[0][0]], polyn) ;
   for (var i=0; i<net.length; i++) {
      var f0 = net[i][0] ;
      if (!edges[f0]) {
         alert("Bad edge description; first edge not connected.") ;
         return ;
      }
      for (var j=1; j<net[i].length; j++) {
         var f1 = net[i][j] ;
         if (f1 == "" || edges[f1])
            continue ;
         edges[f1] = [edges[f0][j%polyn], edges[f0][(j+polyn-1)%polyn]] ;
         extendedges(edges[f1], polyn) ;
      }
   }
   for (var f0 in edges) {
      var es = edges[f0] ;
      for (var i=0; i<es.length; i++) {
         minx = Math.min(minx, es[i][0]) ;
         maxx = Math.max(maxx, es[i][0]) ;
         miny = Math.min(miny, es[i][1]) ;
         maxy = Math.max(maxy, es[i][1]) ;
      }
   }
   var sc = Math.min(w/(maxx-minx), h/(maxy-miny)) ;
   var xoff = 0.5*(w-sc*(maxx+minx)) ;
   var yoff = 0.5*(h-sc*(maxy+miny)) ;
   var geos = {} ;
   var bg = pg.getboundarygeometry() ;
   edges2 = {} ;
   var initv = [[sc+xoff, yoff], [xoff, yoff]] ;
   edges2[net[0][0]] = initv ;
   extendedges(edges2[net[0][0]], polyn) ;
   geos[bg.facenames[0][1]] = pg.project2d(0, 0,
                 [Quat(0, initv[0][0], initv[0][1], 0),
                  Quat(0, initv[1][0], initv[1][1], 0)]) ;
   var connectat = [] ;
   connectat[0] = 0 ;
   for (var i=0; i<net.length; i++) {
      var f0 = net[i][0] ;
      if (!edges2[f0]) {
         alert("Bad edge description; first edge not connected.") ;
         return ;
      }
      var gfi = -1 ;
      for (var j=0; j<bg.facenames.length; j++)
         if (f0 == bg.facenames[j][1]) {
            gfi = j ;
            break ;
         }
      if (gfi < 0) {
         alert("Could not find first face name " + f0) ;
         return 0 ;
      }
      var thisface = bg.facenames[gfi][0] ;
      for (var j=1; j<net[i].length; j++) {
         var f1 = net[i][j] ;
         if (f1 == "" || edges2[f1])
            continue ;
         edges2[f1] = [edges2[f0][j%polyn], edges2[f0][(j+polyn-1)%polyn]] ;
         extendedges(edges2[f1], polyn) ;
         // what edge are we at?
         var caf0 = connectat[gfi] ;
         var mp = thisface[(caf0+j)%polyn].sum(thisface[(caf0+j+polyn-1)%polyn]).smul(0.5) ;
         var epi = pg.findelement(bg.edgenames, mp) ;
         var edgename = bg.edgenames[epi][1] ;
         var gf1 = edgename[(f0 == edgename[0]) ? 1 : 0] ;
         var gf1i = -1 ;
         for (var k=0; k<bg.facenames.length; k++) {
            if (gf1 == bg.facenames[k][1]) {
               gf1i = k ;
               break ;
            }
         }
         if (gf1i < 0) {
            alert("Could not find second face name") ;
            return 0 ;
         }
         var otherface = bg.facenames[gf1i][0] ;
         for (var k=0; k<otherface.length; k++) {
            var mp2 = otherface[k].sum(otherface[(k+1)%polyn]).smul(0.5) ;
            if (mp2.dist(mp) <= eps) {
               var p1 = edges2[f0][(j+polyn-1)%polyn] ;
               var p2 = edges2[f0][j % polyn] ;
               connectat[gf1i] = k ;
               geos[gf1] = pg.project2d(gf1i, k,
                       [Quat(0, p2[0], p2[1], 0), Quat(0, p1[0], p1[1], 0)]) ;
               break ;
            }
         }
      }
   }
   // Let's build arrays for faster rendering.  We want to map from geo
   // base face number to color, and we want to map from geo face number
   // to 2D geometry.  These can be reused as long as the puzzle overall
   // orientation and canvas size remains unchanged.
   pos = pg.getsolved() ;
   colormap = [] ;
   facegeo = [] ;
   for (var i=0; i<pg.basefacecount; i++)
      colormap[i] = pg.colors[pg.facenames[i][1]] ;
   for (var i=0; i<pg.faces.length; i++) {
      var face = pg.faces[i] ;
      var facenum = Math.floor(i/pg.stickersperface) ;
      var g = geos[pg.facenames[facenum][1]] ;
      var face2 = face.map(function(p){
                       return [trim+p.dot(g[0])+g[2].b, trim+canheight-p.dot(g[1])-g[2].c] ; }) ;
      facegeo.push(face2) ;
   }
}
function changeddisplay() {
   if (!pg)
      return ;
   var boundarygeo = pg.getboundarygeometry() ;
   var face0 = boundarygeo.facenames[0][0] ;
   var polyn = face0.length ; // number of vertices; 3, 4, or 5
   trim = 10 ;
   canwidth = 800 - 2 * trim ;
   canheight = 500 - 2 * trim ;
   walknet(pg, boundarygeo.facenames.length, canwidth, canheight) ;
   var svg = [] ;
   for (var i=0; i<pg.faces.length; i++) {
      var cubie = pg.facetocubies[i][0] ;
      var cubieori = pg.facetocubies[i][1] ;
      var cubiesetnum = pg.cubiesetnums[cubie] ;
      var cubieord = pg.cubieordnums[cubie] ;
      var id = pg.cubiesetname[cubiesetnum] + "-l" + cubieord + "-o" + cubieori ;
      svg.push(drawedges(id, facegeo[i], colormap[pos.p[i]])) ;
   }
   html = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 800 500">' +
   '<style type="text/css"><![CDATA[' +
   '.sticker { stroke: #000000; stroke-width: 1px; }' +
   ']]></style>' +
   svg.join('') + "</svg>" ;
   LucasSetup(pg.writeksolve("TwistyPuzzle", true), html, pg.ksolvemovenames) ;
}
function setup() {
   var select = document.getElementById('puzzleoptions') ;
   var puzzledesc = PuzzleGeometry.prototype.getpuzzles() ;
   for (var i=0; i<puzzledesc.length; i += 2) {
      var opt = document.createElement("option") ;
      opt.value = puzzledesc[i] ;
      opt.innerHTML = puzzledesc[i+1] ;
      select.add(opt) ;
   }
   textinput = document.getElementById('desc') ;
   select.onchange = doselection ;
   checkchange() ;
   setInterval(checkchange, 0.5) ;
}
</script>
</head>
<body onload="setup();">
Desc <input type=text id=desc value="c f 0.3333333333" size="50">
</input><br>
<select id="puzzleoptions">
<option value="">custom</option>
</select><br>
<twisty id="custom-example" initialization="custom"></twisty><br>
<div id=data></div><br>
</body>
</html>
